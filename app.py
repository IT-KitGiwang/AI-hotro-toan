from flask import Flask, render_template, request, jsonify, session, redirect, url_for, flash, send_file
from werkzeug.security import generate_password_hash, check_password_hash
import google.generativeai as genai
import PyPDF2
import re
from dotenv import load_dotenv
load_dotenv()
import os
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import time
from flask_session import Session
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from sqlalchemy.sql import text
import pandas as pd
from io import BytesIO
from werkzeug.utils import secure_filename
# ================== C·∫§U H√åNH & KH·ªûI T·∫†O ==================
api_key = os.getenv("GEMINI_API_KEY")
if not api_key:
    raise ValueError("‚ùå Kh√¥ng t√¨m th·∫•y GEMINI_API_KEY trong bi·∫øn m√¥i tr∆∞·ªùng!")

genai.configure(api_key=api_key)

GENERATION_MODEL = 'gemini-2.5-flash-lite'
EMBEDDING_MODEL = 'text-embedding-004'

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY")
app.config["SESSION_TYPE"] = "filesystem"
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
migrate = Migrate(app, db)
Session(app)
# C·∫•u h√¨nh upload folder cho PDF
UPLOAD_FOLDER = './static'
ALLOWED_EXTENSIONS = {'pdf'}
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # Gi·ªõi h·∫°n 16MB

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password = db.Column(db.String(255), nullable=False)
    name = db.Column(db.Text, default='')
    level = db.Column(db.String(20), default='TB')
    history = db.Column(db.Text, default='')
    lydo = db.Column(db.Text, default='')

with app.app_context():
    # ƒê·∫£m b·∫£o schema public t·ªìn t·∫°i
    db.session.execute(text('CREATE SCHEMA IF NOT EXISTS public;'))
    db.create_all()
    print("‚úÖ ƒê√£ ki·ªÉm tra/t·∫°o b·∫£ng users trong schema public")

# Bi·∫øn to√†n c·ª•c cho RAG
RAG_DATA = {
    "chunks": [],
    "embeddings": np.array([]),
    "is_ready": False
}

# ================== ƒê·ªåC & CHIA CHUNKS ==================
def extract_pdf_text(pdf_path):
    text = ""
    try:
        with open(pdf_path, 'rb') as f:
            reader = PyPDF2.PdfReader(f)
            for page in reader.pages:
                text += page.extract_text() or ""
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi ƒë·ªçc PDF {pdf_path}: {e}")
    return text

def create_chunks_from_directory(directory='./static', chunk_size=400):
    all_chunks = []
    if not os.path.exists(directory):
        print(f"Th∆∞ m·ª•c {directory} kh√¥ng t·ªìn t·∫°i.")
        return []
    pdf_files = [f for f in os.listdir(directory) if f.endswith('.pdf')]
    print(f"üîç T√¨m th·∫•y {len(pdf_files)} t·ªáp PDF trong {directory}...")
    if not pdf_files:
        return ["Gi·ªõi thi·ªáu v·ªÅ c√°c ch·ªß ƒë·ªÅ to√°n h·ªçc THCS nh∆∞ s·ªë h·ªçc, ƒë·∫°i s·ªë, h√¨nh h·ªçc."]
    for filename in pdf_files:
        pdf_path = os.path.join(directory, filename)
        content = extract_pdf_text(pdf_path)
        for i in range(0, len(content), chunk_size):
            chunk = content[i:i + chunk_size].strip()
            if chunk:
                all_chunks.append(f"[Ngu·ªìn: {filename}] {chunk}")
    print(f"‚úÖ ƒê√£ t·∫°o t·ªïng c·ªông {len(all_chunks)} ƒëo·∫°n vƒÉn (chunks).")
    return all_chunks

def embed_with_retry(texts, model_name, max_retries=5):
    all_embeddings = []
    for text in texts:
        for attempt in range(max_retries):
            try:
                result = genai.embed_content(model=model_name, content=text)
                all_embeddings.append(result["embedding"])
                break
            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"‚ö†Ô∏è Th·ª≠ l·∫°i l·∫ßn {attempt+1}: {e}")
                    time.sleep(2 ** attempt)
                else:
                    print(f"üí• Th·∫•t b·∫°i sau {max_retries} l·∫ßn: {e}")
                    raise
    return np.array(all_embeddings)

def initialize_rag_data():
    global RAG_DATA
    print("‚è≥ ƒêang kh·ªüi t·∫°o d·ªØ li·ªáu RAG...")
    chunks = create_chunks_from_directory()
    if not chunks:
        print("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ nh√∫ng.")
        return
    try:
        embeddings = embed_with_retry(chunks, EMBEDDING_MODEL)
        RAG_DATA.update({
            "chunks": chunks,
            "embeddings": embeddings,
            "is_ready": True
        })
        print("üéâ Kh·ªüi t·∫°o RAG ho√†n t·∫•t!")
    except Exception as e:
        print(f"‚ùå KH√îNG TH·ªÇ KH·ªûI T·∫†O RAG: {e}")
        RAG_DATA["is_ready"] = False

initialize_rag_data()

# ================== TRUY XU·∫§T NG·ªÆ C·∫¢NH ==================
def retrieve_context(query, top_k=3):
    if not RAG_DATA["is_ready"]:
        return "Kh√¥ng c√≥ t√†i li·ªáu RAG n√†o ƒë∆∞·ª£c t·∫£i."
    try:
        query_vec = embed_with_retry([query], EMBEDDING_MODEL)[0].reshape(1, -1)
        sims = cosine_similarity(query_vec, RAG_DATA["embeddings"])[0]
        top_idxs = np.argsort(sims)[-top_k:][::-1]
        return "\n\n---\n\n".join([RAG_DATA["chunks"][i] for i in top_idxs])
    except Exception as e:
        print(f"‚ùå L·ªói RAG: {e}")
        return "L·ªói khi t√¨m ki·∫øm ng·ªØ c·∫£nh."

# ================== ƒê√ÅNH GI√Å NƒÇNG L·ª∞C ==================
# ================== ƒê√ÅNH GI√Å NƒÇNG L·ª∞C ==================
# ================== ƒê√ÅNH GI√Å NƒÇNG L·ª∞C ==================
def evaluate_student_level(history):
    recent_questions = "\n".join([msg for msg in history[-5:] if msg.startswith("üëß H·ªçc sinh:")])
    prompt = f"""
    D·ª±a tr√™n 5 c√¢u h·ªèi g·∫ßn nh·∫•t c·ªßa h·ªçc sinh sau ƒë√¢y, ƒë√°nh gi√° nƒÉng l·ª±c h·ªçc t·∫≠p m√¥n To√°n THCS:
    {recent_questions}
   
    Ph√¢n lo·∫°i th√†nh m·ªôt trong 4 c·∫•p ƒë·ªô: Gioi, Kha, TB, Yeu.
    Gi·∫£i th√≠ch l√Ω do t·∫°i sao h·ªçc sinh ·ªü m·ª©c ƒë·ªô n√†y.
    Tr·∫£ v·ªÅ c√¢u tr·∫£ l·ªùi v·ªõi ƒë·ªãnh d·∫°ng:
    C·∫•p ƒë·ªô: [Gioi/Kha/TB/Yeu]
    L√Ω do: [Gi·∫£i th√≠ch l√Ω do..., t·ªëi ƒëa 150 t·ª´ ng·∫Øn g·ªçn]
    """
    try:
        model = genai.GenerativeModel(GENERATION_MODEL)
        response = model.generate_content(prompt)
        response_text = response.text.strip()
        # Extract level and reason from response
        level_match = re.search(r'C·∫•p ƒë·ªô: (Gioi|Kha|TB|Yeu)', response_text)
        lydo_match = re.search(r'L√Ω do: (.+)', response_text, re.DOTALL)
        
        level = level_match.group(1) if level_match else "TB"
        lydo = lydo_match.group(1).strip() if lydo_match else "Kh√¥ng c√≥ l√Ω do c·ª• th·ªÉ."
        
        if level not in ['Gioi', 'Kha', 'TB', 'Yeu']:
            level = 'TB'
        return level, lydo
    except Exception as e:
        print(f"‚ùå L·ªói ƒë√°nh gi√°: {e}")
        return 'TB', 'ƒê√°nh gi√° kh√¥ng th√†nh c√¥ng do l·ªói h·ªá th·ªëng.'


# ================== ƒê·ªäNH D·∫†NG TR·∫¢ L·ªúI ==================
def format_response(response):
    # B·∫£o v·ªá c√∫ ph√°p LaTeX b·∫±ng c√°ch t·∫°m th·ªùi thay th·∫ø
    latex_matches = []
    def store_latex(match):
        latex_matches.append(match.group(0))
        return f"__LATEX_{len(latex_matches)-1}__"
    
    # Thay th·∫ø c√°c ƒëo·∫°n LaTeX n·ªôi d√≤ng ($...$) v√† ƒë·ªôc l·∫≠p ($$...$$)
    response = re.sub(r'\$\$([^$]+)\$\$', store_latex, response)
    response = re.sub(r'\$([^$]+)\$', store_latex, response)

    # √Åp d·ª•ng ƒë·ªãnh d·∫°ng Markdown
    formatted = re.sub(r'\*\*(.*?)\*\*', r'<strong style="font-weight:700;">\1</strong>', response)
    formatted = re.sub(r'(?<!\n)\*(?!\s)(.*?)(?<!\s)\*(?!\*)', r'<em style="font-style:italic;">\1</em>', formatted)
    formatted = re.sub(r'(?m)^\s*\*\s+(.*)', r'‚Ä¢ <span style="line-height:1.6;">\1</span>', formatted)
    formatted = formatted.replace('\n', '<br>')

    # √Åp d·ª•ng highlight_terms cho c√°c t·ª´ kh√≥a to√°n h·ªçc
    for term, color in highlight_terms.items():
        formatted = formatted.replace(term, f'<span style="line-height:1.6; background:{color}; color:white; font-weight:bold; padding:2px 4px; border-radius:4px;">{term}</span>')

    # Kh√¥i ph·ª•c c√∫ ph√°p LaTeX
    for i, latex in enumerate(latex_matches):
        formatted = formatted.replace(f"__LATEX_{i}__", latex)

    return f"""
    <div style="
        background:#FAFAFA;
        border-left:6px solid #FFB300;
        padding:10px 15px;
        border-radius:8px;
        line-height:2;
        font-size:15px;
        color:#212121;
        font-family:'Segoe UI', sans-serif;">
        {formatted}
    </div>
    """

# FORMAT TR·∫¢ L·ªúI
highlight_terms = {
    "S·ªë t·ª± nhi√™n": "#59C059",
    "S·ªë nguy√™n": "#59C059",
    "S·ªë h·ªØu t·ªâ": "#59C059",
    "S·ªë th·∫≠p ph√¢n": "#59C059",
    "Ph√¢n s·ªë": "#59C059",
    "T·ªâ s·ªë ‚Äì T·ªâ l·ªá": "#59C059",
    "T·ªâ l·ªá thu·∫≠n ‚Äì T·ªâ l·ªá ngh·ªãch": "#59C059",
    "Bi·ªÉu th·ª©c ƒë·∫°i s·ªë": "#59C059",
    "H·∫±ng ƒë·∫≥ng th·ª©c ƒë√°ng nh·ªõ": "#59C059",
    "Nh√¢n, chia ƒëa th·ª©c": "#59C059",
    "Ph√¢n t√≠ch ƒëa th·ª©c th√†nh nh√¢n t·ª≠": "#59C059",
    "CƒÉn b·∫≠c hai, cƒÉn b·∫≠c ba": "#59C059",
    "L≈©y th·ª´a ‚Äì CƒÉn th·ª©c": "#59C059",
    "Bi·ªÉu th·ª©c ch·ª©a cƒÉn": "#59C059",
    "Gi·∫£i ph∆∞∆°ng tr√¨nh": "#59C059",
    "Ph∆∞∆°ng tr√¨nh b·∫≠c nh·∫•t m·ªôt ·∫©n": "#59C059",
    "Ph∆∞∆°ng tr√¨nh ch·ª©a ·∫©n ·ªü m·∫´u": "#59C059",
    "H·ªá ph∆∞∆°ng tr√¨nh b·∫≠c nh·∫•t hai ·∫©n": "#59C059",
    "B·∫•t ph∆∞∆°ng tr√¨nh ‚Äì H·ªá b·∫•t ph∆∞∆°ng tr√¨nh": "#59C059",
    "Bi·∫øn, gi√° tr·ªã c·ªßa bi·ªÉu th·ª©c": "#59C059",
    "H√†m s·ªë ‚Äì ƒê·ªì th·ªã h√†m s·ªë": "#59C059",
    "H√†m s·ªë b·∫≠c nh·∫•t: y=ax+b": "#59C059",
    "ƒêi·ªÉm, ƒë∆∞·ªùng th·∫≥ng, tia, ƒëo·∫°n th·∫≥ng": "#5CB1D6",
    "G√≥c ‚Äì S·ªë ƒëo g√≥c": "#5CB1D6",
    "Hai ƒë∆∞·ªùng th·∫≥ng song song ‚Äì vu√¥ng g√≥c ‚Äì c·∫Øt nhau": "#5CB1D6",
    "Tam gi√°c": "#5CB1D6",
    "Tam gi√°c ƒë·ªÅu, c√¢n, vu√¥ng": "#5CB1D6",
    "T√≠nh ch·∫•t c·∫°nh ‚Äì g√≥c ‚Äì ƒë∆∞·ªùng cao ‚Äì trung tuy·∫øn ‚Äì ph√¢n gi√°c": "#5CB1D6",
    "ƒê·ªãnh l√Ω Pythagoras": "#5CB1D6",
    "C√°c tr∆∞·ªùng h·ª£p b·∫±ng nhau c·ªßa tam gi√°c: C·∫°nh ‚Äì C·∫°nh ‚Äì C·∫°nh (CCC), G√≥c ‚Äì C·∫°nh ‚Äì G√≥c (GCG)": "#5CB1D6",
    "T·ª© gi√°c": "#5CB1D6",
    "H√¨nh thang, h√¨nh b√¨nh h√†nh, h√¨nh ch·ªØ nh·∫≠t, h√¨nh vu√¥ng, h√¨nh thoi": "#5CB1D6",
    "ƒê∆∞·ªùng tr√≤n": "#5CB1D6",
    "B√°n k√≠nh, ƒë∆∞·ªùng k√≠nh, d√¢y cung, ti·∫øp tuy·∫øn": "#5CB1D6",
    "Di·ªán t√≠ch ‚Äì Chu vi c√°c h√¨nh ph·∫≥ng": "#5CB1D6",
    "Th·ªÉ t√≠ch c√°c kh·ªëi h√¨nh": "#5CB1D6",
    "H√¨nh h·ªôp ch·ªØ nh·∫≠t": "#5CB1D6",
    "H√¨nh l·∫≠p ph∆∞∆°ng": "#5CB1D6",
    "H√¨nh lƒÉng tr·ª• ƒë·ª©ng": "#5CB1D6",
    "H√¨nh ch√≥p": "#5CB1D6",
    "H√¨nh tr·ª• ‚Äì h√¨nh n√≥n ‚Äì h√¨nh c·∫ßu (l·ªõp 9)": "#5CB1D6",
    "ƒê∆∞·ªùng trung tr·ª±c, ƒë∆∞·ªùng ph√¢n gi√°c": "#5CB1D6",
    "T·ªça ƒë·ªô trong m·∫∑t ph·∫≥ng": "#5CB1D6"
}

# ================== ROUTES ==================
@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        name = request.form.get('name', '').strip()  # L·∫§Y T√äN H·ªåC SINH
        if not username or not password:
            flash('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß t√™n ƒëƒÉng nh·∫≠p v√† m·∫≠t kh·∫©u.', 'error')
            return redirect(url_for('register'))
        if not name:
            flash('Vui l√≤ng nh·∫≠p t√™n h·ªçc sinh.', 'error')
            return redirect(url_for('register'))

        if User.query.filter_by(username=username).first():
            flash('T√™n ƒëƒÉng nh·∫≠p ƒë√£ t·ªìn t·∫°i.', 'error')
            return redirect(url_for('register'))

        try:
            hashed_password = generate_password_hash(password, method='pbkdf2:sha256')
            user = User(username=username, password=hashed_password, name=name)
            db.session.add(user)
            db.session.commit()
            flash('ƒêƒÉng k√Ω th√†nh c√¥ng! Vui l√≤ng ƒëƒÉng nh·∫≠p.', 'success')
            return redirect(url_for('login'))
        except Exception as e:
            db.session.rollback()
            print(f"Error during registration: {str(e)}")
            flash(f'L·ªói khi ƒëƒÉng k√Ω: {str(e)}', 'error')
            return redirect(url_for('register'))
    return render_template('register.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        if not username or not password:
            flash('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß t√™n ƒëƒÉng nh·∫≠p v√† m·∫≠t kh·∫©u.', 'error')
            return redirect(url_for('login'))
        user = User.query.filter_by(username=username).first()
        if user and check_password_hash(user.password, password):
            session['user_id'] = user.id
            session['history'] = user.history.split('\n') if user.history else []
            flash('ƒêƒÉng nh·∫≠p th√†nh c√¥ng!', 'success')
            return redirect(url_for('index'))
        flash('T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng.', 'error')
        return redirect(url_for('login'))
    return render_template('login.html')

@app.route('/logout')
def logout():
    if 'user_id' in session:
        user = db.session.get(User, session['user_id'])
        if user:
            user.history = '\n'.join(session.get('history', []))
            db.session.commit()
            print(f"User {user.username} history updated")
        else:
            print(f"User with ID {session['user_id']} not found")
    session.clear()
    flash('ƒê√£ ƒëƒÉng xu·∫•t th√†nh c√¥ng.', 'success')
    return redirect(url_for('login'))

@app.route('/trochoi')
def trochoi():
    return render_template('trochoi.html')

@app.route('/')
def index():
    if 'user_id' not in session:
        flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ ti·∫øp t·ª•c.', 'error')
        return redirect(url_for('login'))
    rag_status = "‚úÖ ƒê√£ t·∫£i t√†i li·ªáu RAG th√†nh c√¥ng" if RAG_DATA["is_ready"] else "‚ö†Ô∏è Ch∆∞a t·∫£i ƒë∆∞·ª£c t√†i li·ªáu RAG."
    user = db.session.get(User, session['user_id'])
    if not user:
        flash('Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.', 'error')
        return redirect(url_for('login'))
    return render_template('index.html', rag_status=rag_status, user_level=user.level)

@app.route('/chat', methods=['POST'])
def chat():
    if 'user_id' not in session:
        return jsonify({'error': 'Vui l√≤ng ƒëƒÉng nh·∫≠p'}), 401

    user_message = request.json.get('message', '')
    if not user_message:
        return jsonify({'response': format_response('Con h√£y nh·∫≠p c√¢u h·ªèi nh√©!')})

    # Load history from session
    history = session.get('history', [])
    history.append(f"üëß H·ªçc sinh: {user_message}")

    # üîç Truy xu·∫•t ng·ªØ c·∫£nh RAG
    related_context = retrieve_context(user_message)
    recent_history = "\n".join(history[-5:])

    # L·∫•y level t·ª´ DB
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i'}), 401
    student_level = user.level

    prompt = f"""
    B·∫°n l√† m·ªôt **Th·∫ßy/C√¥ gi√°o d·∫°y to√°n THCS**, x∆∞ng l√† th·∫ßy v√† con.
    H√£y tr·∫£ l·ªùi ng·∫Øn g·ªçn, th√¢n thi·ªán, d·ªÖ hi·ªÉu, tr√¨nh b√†y theo t·ª´ng b∆∞·ªõc th·ª±c hi·ªán.
    S·ª≠ d·ª•ng c√∫ ph√°p LaTeX cho c√°c c√¥ng th·ª©c to√°n h·ªçc.
    Format m√†u cho c√°c t·ª´ kh√≥a to√°n h·ªçc gi√∫p h·ªçc sinh d·ªÖ d√†ng t√¨m ki·∫øm: {highlight_terms}
    ƒê·ªëi v·ªõi c√°c kh√°i ni·ªám ƒë∆∞·ª£c s·ª≠ d·ª•ng, b·ªçc trong th·∫ª <span style="line-height:1.6; background: (m√†u d·ª±a tr√™n highlight_terms); color:white; font-weight:bold; padding:2px 4px; border-radius:4px;">{{term}}</span>
    üéØ T√†i li·ªáu RAG:
    {related_context}
    üó£Ô∏è L·ªãch s·ª≠ h·ªôi tho·∫°i g·∫ßn ƒë√¢y:
    {recent_history}
    ƒê·ªëi v·ªõi c√°c c√¢u h·ªèi kh√¥ng c√≥ t·ª´ "b√†i t·∫≠p m·∫´u v√≠ d·ª•" ho·∫∑c t∆∞∆°ng t·ª±, tr·∫£ l·ªùi d·ª±a theo l·ªãch s·ª≠ h·ªôi tho·∫°i.
    ƒê·ªëi v·ªõi c√°c c√¢u h·ªèi mu·ªën tham kh·∫£o b√†i t·∫≠p m·∫´u trong t√†i li·ªáu RAG, ch·ªâ h·ªçc sinh c√°ch l√†m theo c√¢u h·ªèi, ng·∫Øn g·ªçn v√† d·ªÖ hi·ªÉu.
    D·ª±a v√†o nƒÉng l·ª±c c·ªßa h·ªçc sinh l√† {student_level}, ƒëi·ªÅu ch·ªânh c√¢u tr·∫£ l·ªùi:
    - N·∫øu Gioi: Gi·∫£i th√≠ch s√¢u h∆°n, ƒë∆∞a b√†i t·∫≠p n√¢ng cao.
    - N·∫øu Kha: Gi·∫£i th√≠ch chi ti·∫øt v·ªõi v√≠ d·ª•.
    - N·∫øu TB: Gi·∫£i th√≠ch c∆° b·∫£n, nhi·ªÅu b∆∞·ªõc nh·ªè.
    - N·∫øu Yeu: Gi·∫£i th√≠ch ƒë∆°n gi·∫£n nh·∫•t, l·∫∑p l·∫°i ki·∫øn th·ª©c c∆° b·∫£n.
    N·∫øu y√™u c·∫ßu b√†i t·∫≠p, ƒë∆∞a b√†i ph√π h·ª£p v·ªõi level.
    üß† C√¢u h·ªèi m·ªõi: {user_message}
    """

    try:
        model = genai.GenerativeModel(GENERATION_MODEL)
        response = model.generate_content(prompt)
        ai_text = response.text

        # L∆∞u tr·∫£ l·ªùi AI v√†o history
        history.append(f"üßë‚Äçüè´ Th·∫ßy/C√¥: {ai_text}")

        # ƒê√°nh gi√° level n·∫øu ƒë·ªß 5 c√¢u h·ªèi m·ªõi
        student_questions = [msg for msg in history if msg.startswith("üëß H·ªçc sinh:")]
        if len(student_questions) % 5 == 0:
            new_level, lydo = evaluate_student_level(history)
            user.level = new_level
            user.lydo = lydo  # l∆∞u l√Ω do v√†o c·ªôt lydo
            db.session.commit()
            print(f"User {user.username} level updated to {new_level} with reason: {lydo}")

        # L∆∞u l·ªãch s·ª≠ c√¢u h·ªèi h·ªçc sinh v√†o session v√† database
        history_questions = student_questions
        # ƒê·∫£m b·∫£o m·ªói tin nh·∫Øn xu·ªëng d√≤ng ri√™ng bi·ªát
        session['history'] = history_questions
        user.history = '\n'.join([msg.strip() for msg in history_questions])  # X√≥a kho·∫£ng tr·∫Øng th·ª´a v√† n·ªëi b·∫±ng \n
        db.session.commit()
        session.modified = True
        print(f"User {user.username} history updated in database: {user.history}")

        return jsonify({'response': format_response(ai_text)})

    except Exception as e:
        print(f"‚ùå L·ªói Gemini: {e}")
        return jsonify({'response': format_response("Th·∫ßy Gemini h∆°i m·ªát, con th·ª≠ l·∫°i sau nh√©!")})
# QU·∫¢N L√ù H·ªåC SINH
@app.route('/admin', methods=['GET', 'POST'])
def admin():
    if 'admin_session' not in session:
        if request.method == 'POST':
            username = request.form.get('username')
            password = request.form.get('password')
            if username == 'thaygiao123':
                user = User.query.filter_by(username=username).first()
                if user and check_password_hash(user.password, password):
                    session['admin_session'] = True
                    flash('ƒêƒÉng nh·∫≠p admin th√†nh c√¥ng!', 'success')
                    return redirect(url_for('admin'))
                else:
                    flash('T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng.', 'error')
            else:
                flash('T√™n ƒëƒÉng nh·∫≠p admin kh√¥ng ƒë√∫ng.', 'error')
        return render_template('admin_login.html')
    
    # X·ª≠ l√Ω upload file PDF
    if request.method == 'POST' and 'file' in request.files:
        file = request.files['file']
        if file.filename == '':
            flash('Kh√¥ng c√≥ file ƒë∆∞·ª£c ch·ªçn.', 'error')
        elif file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(file_path)
            flash(f'Upload {filename} th√†nh c√¥ng! ƒê√£ c·∫≠p nh·∫≠t RAG.', 'success')
            initialize_rag_data()
        else:
            flash('Ch·ªâ ch·∫•p nh·∫≠n file PDF!', 'error')
    
    pdf_files = [f for f in os.listdir(app.config['UPLOAD_FOLDER']) if f.endswith('.pdf')] if os.path.exists(app.config['UPLOAD_FOLDER']) else []
    
    # L·∫•y d·ªØ li·ªáu users + t√™n h·ªçc sinh
    users = User.query.all()
    user_data = []
    for user in users:
        user_data.append({
            'id': user.id,
            'username': user.username,
            'name': user.name or "Ch∆∞a ƒë·∫∑t t√™n",  # HI·ªÇN TH·ªä T√äN
            'level': user.level,
            'lydo': user.lydo,
            'history': user.history if user.history else 'Ch∆∞a c√≥ l·ªãch s·ª≠'
        })
    
    return render_template('admin.html', pdf_files=pdf_files, user_data=user_data)

@app.route('/admin/delete_pdf/<filename>', methods=['POST'])
def delete_pdf(filename):
    if 'admin_session' not in session or not session['admin_session']:
        flash('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.', 'error')
        return redirect(url_for('admin'))
    
    file_path = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))
    if os.path.exists(file_path):
        try:
            os.remove(file_path)
            flash(f'X√≥a file {filename} th√†nh c√¥ng! ƒê√£ c·∫≠p nh·∫≠t RAG.', 'success')
            initialize_rag_data()  # Re-init RAG sau khi x√≥a
        except Exception as e:
            flash(f'L·ªói khi x√≥a file {filename}: {str(e)}', 'error')
    else:
        flash(f'File {filename} kh√¥ng t·ªìn t·∫°i.', 'error')
    
    return redirect(url_for('admin'))

@app.route('/admin/export_csv')
def export_csv():
    if 'admin_session' not in session or not session['admin_session']:
        flash('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.', 'error')
        return redirect(url_for('admin'))
    
    users = User.query.all()
    user_data = []
    for user in users:
        user_data.append({
            'ID': user.id,
            'T√™n ƒëƒÉng nh·∫≠p': user.username,
            'T√™n h·ªçc sinh': user.name or "Ch∆∞a ƒë·∫∑t t√™n",  # TH√äM C·ªòT T√äN
            'NƒÉng l·ª±c': user.level,
            'L√Ω do': user.lydo,
            'L·ªãch s·ª≠': user.history if user.history else 'Ch∆∞a c√≥ l·ªãch s·ª≠'
        })
    
    df = pd.DataFrame(user_data)
    output = BytesIO()
    df.to_csv(output, index=False, encoding='utf-8-sig')
    output.seek(0)
    
    return send_file(
        output,
        mimetype='text/csv',
        as_attachment=True,
        download_name='ket_qua_hoc_tap.csv'
    )
@app.route('/admin/logout')
def admin_logout():
    session.pop('admin_session', None)
    flash('ƒê√£ ƒëƒÉng xu·∫•t admin.', 'success')
    return redirect(url_for('admin'))

# ================== CH·∫†Y APP ==================
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)